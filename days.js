// Generated by CoffeeScript 2.7.0
(function() {
  var Graph, bold, drawScreen, fit, floor, fontFamily, fontHeight, fontWidth, graph, mouseDownAct, mouseUpAct, redrawScreen, regular, resizeAct, round, timer, wheelAct;

  ({round, floor} = Math);

  // Constants
  fontHeight = 14;

  fontWidth = fontHeight * .75;

  fontFamily = 'Roboto Mono';

  regular = fontHeight + 'px ' + fontFamily;

  bold = 'bold ' + fontHeight + 'px ' + fontFamily;

  timer = performance.now();

  graph = {};

  // fit fits a value between 0 and 1 proportionally to its distance to min and max
  fit = function(val, min, max) {
    return (val - min) / (max - min);
  };

  Graph = class Graph {
    constructor(containerName) {
      var changeSettings, mouseMoveAct, req;
      req = new XMLHttpRequest();
      req.open('GET', 'https://gadfly16.github.io/sagacity/frames.json');
      req.responseType = 'json';
      this.container = document.getElementById(containerName);
      this.start_elm = this.container.querySelector('#settings>#start');
      this.duration_elm = this.container.querySelector('#settings>#duration');
      this.period_elm = this.container.querySelector('#settings>#period');
      this.goal_elm = this.container.querySelector('#settings>#goal');
      this.canvas = this.container.querySelector('.canvas');
      this.focus = 0;
      this.padLeft = 30;
      this.padRight = 30;
      this.padTop = 20;
      this.padBottom = 40;
      this.setCanvasSize();
      graph = this;
      changeSettings = function() {
        var end, fi, i, reBuyPrice, reSellPrice;
        graph.start = (Math.floor((new Date(graph.start_elm.value)).getTime() / 1000) - graph.frameList[0].ft) / 86400 + 1;
        graph.duration = parseInt(graph.duration_elm.value);
        graph.period = parseInt(graph.period_elm.value);
        graph.goal = parseFloat(graph.goal_elm.value);
        console.log(graph.start, graph.duration, graph.period, graph.goal);
        // Find trade chances
        i = 0;
        end = graph.frameList.length - graph.period;
        while (i < end) {
          graph.frameList[i].reBuy = null;
          graph.frameList[i].reSell = null;
          reBuyPrice = graph.frameList[i].mn / graph.goal;
          reSellPrice = graph.frameList[i].mx * graph.goal;
          fi = i + 1;
          while (fi <= i + graph.period && !(graph.frameList[i].reBuy && graph.frameList[i].reSell)) {
            // console.log(i,fi)
            if (graph.frameList[fi].mx < reBuyPrice && !graph.frameList[i].reBuy) {
              graph.frameList[i].reBuy = fi;
            }
            if (graph.frameList[fi].mn > reSellPrice && !graph.frameList[i].reSell) {
              graph.frameList[i].reSell = fi;
            }
            fi++;
          }
          i++;
        }
        return redrawScreen();
      };
      mouseMoveAct = function(e) {
        var x, y;
        x = e.offsetX;
        y = e.offsetY;
        if (x > graph.padLeft && x < graph.padLeft + graph.width && y > graph.padTop && y < graph.padTop + graph.height) {
          graph.focus = floor((x - graph.padLeft) / (graph.width / graph.duration));
        }
        return redrawScreen();
      };
      req.onload = function() {
        graph.container.querySelectorAll('input').forEach(function(item) {
          return item.addEventListener('change', changeSettings);
        });
        // window.onmousedown = mouseDownAct
        // window.onmouseup = mouseUpAct
        graph.canvas.onmousemove = mouseMoveAct;
        window.onresize = resizeAct;
        // window.onwheel = wheelAct
        graph.frameList = req.response;
        changeSettings();
        return console.log(graph.frameList);
      };
      req.send();
    }

    setCanvasSize() {
      var width;
      width = this.container.getBoundingClientRect().width;
      this.canvas.width = width;
      this.canvas.height = width / 2;
      this.width = this.canvas.width - this.padLeft - this.padRight;
      return this.height = this.canvas.height - this.padTop - this.padBottom;
    }

    changeSettings() {
      var end, fi, i, reBuyPrice, reSellPrice;
      this.start = (Math.floor((new Date(this.start_elm.value)).getTime() / 1000) - this.frameList[0].ft) / 86400 + 1;
      this.duration = parseInt(this.duration_elm.value);
      this.period = parseInt(this.period_elm.value);
      this.goal = parseFloat(this.goal_elm.value);
      // Find trade chances
      i = 0;
      end = this.frameList.length - this.period;
      while (i < end) {
        this.frameList[i].reBuy = null;
        this.frameList[i].reSell = null;
        reBuyPrice = this.frameList[i].mn / this.goal;
        reSellPrice = this.frameList[i].mx * this.goal;
        fi = i + 1;
        while (fi <= i + this.period && !(this.frameList[i].reBuy || this.frameList[i].reSell)) {
          // console.log(i,fi)
          if (this.frameList[fi].mx < reBuyPrice && !this.frameList[i].reBuy) {
            this.frameList[i].reBuy = fi;
          }
          if (this.frameList[fi].mn > reSellPrice && !this.frameList[i].reSell) {
            this.frameList[i].reSell = fi;
          }
          fi++;
        }
        i++;
      }
      return redrawScreen();
    }

    draw() {
      var barHeight, barWidth, ctx, f, fdt, fh, fmax, fmaxWidth, fmin, fminWidth, fx, fy, gap, i, max, min, offset, rb, rbp, rbt, rs, rsp, rst, t, x, y;
      ctx = this.canvas.getContext('2d');
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.save();
      ctx.lineWidth = 2;
      max = this.frameList[this.start].mx;
      min = this.frameList[this.start].mn;
      i = this.start + 1;
      while (i <= this.start + this.duration) {
        max = Math.max(max, this.frameList[i].mx);
        min = Math.min(min, this.frameList[i].mn);
        i++;
      }
      f = this.start + this.focus;
      // Draw bars
      barWidth = this.width / this.duration;
      gap = 0.1;
      offset = this.start;
      i = 0;
      while (i <= this.duration) {
        x = i * barWidth + this.padLeft;
        y = fit(this.frameList[offset + i].mx, max, min) * this.height;
        barHeight = fit(this.frameList[offset + i].mn, max, min) * this.height - y;
        if (offset + i === f) {
          // Draw focus line
          ctx.fillStyle = '#909090';
          ctx.fillRect(x, 0, barWidth, this.canvas.height);
          // Store focus values for later use
          fx = x + barWidth / 2;
          fy = y + this.padTop;
          fh = barHeight;
        }
        ctx.fillStyle = '#404040';
        if (this.frameList[offset + i].reSell) {
          ctx.fillStyle = '#20b020';
        }
        ctx.fillRect(x + barWidth * gap / 2, y + this.padTop, barWidth * (1 - gap), barHeight / 2);
        ctx.fillStyle = '#404040';
        if (this.frameList[offset + i].reBuy) {
          ctx.fillStyle = '#b04020';
        }
        ctx.fillRect(x + barWidth * gap / 2, y + this.padTop + barHeight / 2, barWidth * (1 - gap), barHeight / 2);
        i++;
      }
      // Draw focus info
      ctx.fillStyle = '#404040';
      ctx.font = bold;
      ctx.textAlign = 'center';
      // console.log(@start+@focus)
      fdt = (new Date(this.frameList[f].ft * 1000)).toDateString();
      fmax = String(this.frameList[f].mx);
      fmaxWidth = fontWidth * fmax.length;
      fmin = String(this.frameList[f].mn);
      fminWidth = fontWidth * fmin.length;
      ctx.fillRect(fx - fmaxWidth / 2, fy - fontHeight - 20, fmaxWidth, fontHeight + 8);
      ctx.fillRect(fx - fminWidth / 2, fy + fh + 12, fminWidth, fontHeight + 8);
      ctx.fillStyle = '#a0a0a0';
      ctx.fillText(fmax, fx, fy - 17);
      ctx.fillText(fmin, fx, fy + fh + 15 + fontHeight);
      ctx.fillStyle = '#404040';
      ctx.fillText(fdt, this.canvas.width / 2, this.canvas.height - 15);
      rs = this.frameList[f].reSell;
      if (rs) {
        ctx.strokeStyle = '#20f020';
        ctx.beginPath();
        ctx.moveTo(fx, fy);
        ctx.lineTo(fx + (rs - f) * barWidth, fit(this.frameList[rs].mn, max, min) * this.height + this.padTop);
        ctx.stroke();
        ctx.fillStyle = '#20b020';
        ctx.textAlign = 'right';
        rst = "Re-sell in " + (rs - f) + " days at ";
        rsp = this.frameList[rs].mn;
        ctx.fillText(rst + rsp + " ", this.canvas.width / 2, 20);
      }
      rb = this.frameList[f].reBuy;
      if (rb) {
        ctx.strokeStyle = '#f02020';
        ctx.beginPath();
        ctx.moveTo(fx, fy + fh);
        ctx.lineTo(fx + (rb - f) * barWidth, fit(this.frameList[rb].mx, max, min) * this.height + this.padTop);
        ctx.stroke();
        ctx.fillStyle = '#b02020';
        ctx.textAlign = 'left';
        rbt = " Re-buy in " + (rb - f) + " days at ";
        rbp = this.frameList[rb].mx;
        ctx.fillText(rbt + rbp, this.canvas.width / 2, 20);
      }
      // FPS
      t = performance.now();
      ctx.font = regular;
      ctx.textAlign = 'left';
      ctx.fillText(round(1000 / (t - timer)) + " FPS", 30, 30);
      timer = t;
      return ctx.restore();
    }

  };

  resizeAct = function() {
    graph.setCanvasSize();
    return redrawScreen();
  };

  wheelAct = function(e) {
    var delta, scale;
    if (e.shiftKey) {
      vp.rot += e.deltaY / 180 / vp.scale ** .5;
    } else {
      delta = e.deltaY * -0.01;
      scale = vp.scale * (1 + delta);
      scale = max(.001, Math.min(1000, scale));
      vp.offx += (vp.width / 2 - e.clientX) * delta * vp.sep ** 2 / vp.unit;
      vp.offy += (vp.height / 2 - e.clientY) * delta * vp.sep ** 2 / vp.unit;
      vp.scale = scale;
      vp.update();
    }
    return redrawScreen();
  };

  mouseDownAct = function(e) {
    console.log("Pressed$ " + e.clientX);
    vp.panx = e.clientX;
    vp.pany = e.clientY;
    vp.panstx = vp.offx;
    vp.pansty = vp.offy;
    return vp.panning = true;
  };

  mouseUpAct = function(e) {
    return vp.panning = false;
  };

  redrawScreen = function() {
    return window.requestAnimationFrame(drawScreen);
  };

  drawScreen = function() {
    return graph.draw();
  };

  // Entry point. Just like that.
  graph = new Graph("doc_graph");

}).call(this);
