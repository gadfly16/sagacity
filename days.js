// Generated by CoffeeScript 2.7.0
(function() {
  var Graph, bold, drawScreen, fit, fontFamily, fontHeight, fontWidth, graph, mouseDownAct, mouseMoveAct, mouseUpAct, redrawScreen, regular, resizeAct, round, timer, wheelAct;

  ({round} = Math);

  // Constants
  fontHeight = 14;

  fontWidth = fontHeight * .75;

  fontFamily = 'Roboto Mono';

  regular = fontHeight + 'px ' + fontFamily;

  bold = 'bold ' + fontHeight + 'px ' + fontFamily;

  timer = performance.now();

  graph = {};

  // fit fits a value between 0 and 1 proportionally to its distance to min and max
  fit = function(val, min, max) {
    return (val - min) / (max - min);
  };

  Graph = class Graph {
    constructor(containerName) {
      var req;
      req = new XMLHttpRequest();
      req.open('GET', 'https://gadfly16.github.io/sagacity/frames.json');
      req.responseType = 'json';
      this.container = document.getElementById(containerName);
      this.start_elm = this.container.querySelector('#settings>#start');
      this.duration_elm = this.container.querySelector('#settings>#duration');
      this.period_elm = this.container.querySelector('#settings>#period');
      this.goal_elm = this.container.querySelector('#settings>#start');
      this.canvas = this.container.querySelector('.canvas');
      this.setCanvasSize();
      graph = this;
      req.onload = function() {
        graph.frameList = req.response;
        graph.changeSettings();
        graph.container.querySelectorAll('input').forEach(function(item) {
          return item.addEventListener('change', graph.changeSettings);
        });
        if (graph.canvas.getContext) {
          // window.onmousedown = mouseDownAct
          // window.onmouseup = mouseUpAct
          window.onmousemove = mouseMoveAct;
          window.onresize = resizeAct;
          // window.onwheel = wheelAct
          return redrawScreen();
        }
      };
      req.send();
    }

    setCanvasSize() {
      var width;
      width = this.container.getBoundingClientRect().width;
      this.canvas.width = width;
      return this.canvas.height = width / 2;
    }

    changeSettings() {
      var end, fi, i, reBuyPrice, reSellPrice, results;
      this.start = (Math.floor((new Date(this.start_elm.value)).getTime() / 1000) - this.frameList[0].ft) / 86400 + 1;
      this.duration = parseInt(this.duration_elm.value);
      this.period = parseInt(this.period_elm.value);
      this.goal = parseFloat(this.goal_elm.value);
      // console.log(@start,@duration,@period,@goal)

      // Find trade chances
      i = 0;
      end = this.frameList.length - this.period;
      results = [];
      while (i < end) {
        this.frameList[i].reBuy = null;
        this.frameList[i].reSell = null;
        reBuyPrice = this.frameList[i].mn / this.goal;
        reSellPrice = this.frameList[i].mx * this.goal;
        fi = i + 1;
        while (fi <= i + this.period && !(this.frameList[i].reBuy || this.frameList[i].reSell)) {
          // console.log(i,fi)
          if (this.frameList[fi].mx < reBuyPrice && !this.frameList[i].reBuy) {
            this.frameList[i].reBuy = fi;
          }
          if (this.frameList[fi].mn > reSellPrice && !this.frameList[i].reSell) {
            this.frameList[i].reSell = fi;
          }
          fi++;
        }
        results.push(i++);
      }
      return results;
    }

    draw() {
      var barHeight, barWidth, cnvRect, ctx, i, max, min, offset, t, x, y;
      ctx = this.canvas.getContext('2d');
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.save();
      cnvRect = this.canvas.getBoundingClientRect();
      // Find min and max of displayed frames
      max = this.frameList[this.start].mx;
      min = this.frameList[this.start].mn;
      i = this.start + 1;
      while (i <= this.start + this.duration) {
        max = Math.max(max, this.frameList[i].mx);
        min = Math.min(min, this.frameList[i].mn);
        i++;
      }
      
      // Draw bars
      ctx.fillStyle = '#ff0000';
      barWidth = cnvRect.width / this.duration;
      offset = this.start;
      i = 0;
      while (i <= this.duration) {
        x = i * barWidth;
        y = (1 - fit(this.frameList[offset + i].mx, min, max)) * cnvRect.height;
        barHeight = (1 - fit(this.frameList[offset + i].mn, min, max)) * cnvRect.height - y;
        ctx.fillRect(x, y, barWidth, barHeight);
        i++;
      }
      // FPS
      t = performance.now();
      ctx.font = regular;
      ctx.textAlign = 'left';
      ctx.fillText(round(1000 / (t - timer)) + " FPS", 50, 50);
      timer = t;
      return ctx.restore();
    }

  };

  resizeAct = function() {
    graph.setCanvasSize();
    return redrawScreen();
  };

  wheelAct = function(e) {
    var delta, scale;
    if (e.shiftKey) {
      vp.rot += e.deltaY / 180 / vp.scale ** .5;
    } else {
      delta = e.deltaY * -0.01;
      scale = vp.scale * (1 + delta);
      scale = max(.001, Math.min(1000, scale));
      vp.offx += (vp.width / 2 - e.clientX) * delta * vp.sep ** 2 / vp.unit;
      vp.offy += (vp.height / 2 - e.clientY) * delta * vp.sep ** 2 / vp.unit;
      vp.scale = scale;
      vp.update();
    }
    return redrawScreen();
  };

  mouseDownAct = function(e) {
    console.log("Pressed$ " + e.clientX);
    vp.panx = e.clientX;
    vp.pany = e.clientY;
    vp.panstx = vp.offx;
    vp.pansty = vp.offy;
    return vp.panning = true;
  };

  mouseMoveAct = function(e) {
    // if vp.panning
    //   vp.offx = vp.panstx + (e.clientX - vp.panx) / vp.unit
    //   vp.offy = vp.pansty + (e.clientY - vp.pany) / vp.unit
    //   vp.update()
    // vp.pX = e.clientX
    // vp.pY = e.clientY
    return redrawScreen();
  };

  mouseUpAct = function(e) {
    return vp.panning = false;
  };

  redrawScreen = function() {
    return window.requestAnimationFrame(drawScreen);
  };

  drawScreen = function() {
    return graph.draw();
  };

  // Entry point. Just like that.
  graph = new Graph("doc_graph");

}).call(this);
